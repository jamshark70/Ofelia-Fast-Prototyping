local canvas = ofCanvas(this);
local args = canvas:getArgs();
local outlet = ofOutlet(this);
M.image = ofFbo();
local width, height, type, autoclear = 256, 256, GL_RGBA, 1;
local clear = ofColor(0, 0, 0, 255);
;
function M.new();
ofWindow.addListener("setup", this);
if args[1] == nil then width = 256 else width = args[1] end;
if args[2] == nil then height = 256 else height = args[2] end;
if args[3] == nil then atoclear = 1 else autoclear = args[3] end;
M.setup() end;
;
function M.free();
ofWindow.removeListener("setup", this);
end;
;
function M.setup();
if ofWindow.exists then M.image:allocate(width, height, type) M.image:beginFbo() ofClear(clear) M.image:endFbo() end end;
;
function M.allocate(l) width=l[1] height=l[2] M.image:allocate(width, height, type) end;
function M.garbage(l) width=l[1] height=l[2] M.image:allocate(width, height, type) M.image:beginFbo() ofClear(0, 0, 0, 255) M.image:endFbo() end;
function M.clear() if ofWindow.exists then M.image:clear() end end;
function M.autoclear(f) autoclear = f end;
function M.fill(l) clear.r=l[1] clear.g=l[2] clear.b=l[3] clear.a=l[4] M.image:beginFbo() ofClear(clear) M.image:endFbo() end;
function M.updatetexture() M.image:updateTexture() end;
function M.draw(list) M.image:draw(list[1], list[2], list[3]) end;
function M.crop(l) M.image:crop(l[1], l[2], l[3], l[4]) end;
function M.cropfrom(l) M.image:cropfrom(M.image, l[1], l[2], l[3], l[4]) end;
function M.drawsubsection(l) M.image:drawSubsection(l[1], l[2], l[3], l[4], l[5], l[6]) end;
function M.get() outlet:outletList(2, ofTable (M.image:isAllocated(), M.image:getWidth(), M.image:getHeight(), M.image:getNumTextures())) end;
;
function M.bang();
ofPushMatrix();
M.image:beginFbo();
ofTranslate(width*0.5, height*0.5, 0);
if autoclear == 1 and ofWindow.exists then ofClear(clear) end;
outlet:outletBang(0);
M.image:endFbo();
ofPopMatrix();
outlet:outletBang(1);
end;
