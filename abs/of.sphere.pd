#N canvas 178 93 878 673 12;
#X obj 31 24 inlet;
#X obj 31 225 outlet;
#X obj 90 22 inlet;
#X obj 170 22 inlet;
#X msg 90 48 radius \$1;
#X msg 170 48 res \$1;
#X text 815 617 RI;
#X text 803 713 R.I;
#X obj 31 199 list trim;
#X obj 31 174 ofelia d -k sphere-\$0;
#A __set local c = ofCanvas(this) \; local args = c:getArgs() \; local
radius \, res \, drawmode \, strokeweight \, primode \, debug \, normalsize
= args[1] \, args[2] \, args[3] \, args[4] \, args[5] \, 0 \, 10 \;
local position \, orientation \, scale \, lookat = ofVec3f() \, ofVec3f()
\, ofVec3f(1 \, 1 \, 1) \, ofVec3f() \; \; function M.new() \; ofWindow.addListener("setup"
\, this) \; if args[1] == nil then radius = 100 end \; if args[2] ==
nil then res = 10 end \; if args[3] == nil then drawmode = "fill" end
\; if args[4] == nil then strokeweight = 1 end \; M.setup() end \;
\; function M.setup() \; M.sphere = ofSpherePrimitive() \; M.sphere:set(radius
\, res \, OF_PRIMITIVE_TRIANGLE_STRIP) \; M.sphere:setPosition(position:vec3())
M.sphere:setOrientation(orientation:vec3()) M.sphere:setScale(scale:vec3())
\; end \; \; function M.free() \; ofWindow.removeListener("setup" \,
this) end \; \; function M.list(l) M.radius(l[1]) M.res(l[2]) M.draw(l[3])
M.stroke(l[4]) M.primode(l[5]) end \; function M.radius(f) radius =
float M.sphere:setRadius(f) end \; function M.res(f) res = float M.sphere:setResolution
(f) end \; function M.primode(f) primode = f M.sphere:setMode(f) end
\; function M.draw(s) drawmode = s end \; function M.stroke(f) strokeweight
= f end \; function M.normalsize(float) normalsize=float end \; function
M.debug(f) debug = f end \; function M.position(l) position.x=l[1]
position.y=l[2] position.z=l[3] M.sphere:setPosition(position:vec3())
end \; function M.orientation(l) orientation.x=l[1] orientation.y=l[2]
orientation.z=l[3] M.sphere:setOrientation(orientation:vec3()) end
\; function M.scale(l) scale.x=l[1] scale.y=l[2] scale.z=l[3] M.sphere:setScale(scale:vec3())
end \; function M.lookat(l) lookat.x=l[1] lookat.y=l[2] lookat.z=l[3]
M.sphere:lookAt(lookat:vec3()) end \; function M.texture(f) if f >
0 then M.sphere:enableTextures() else M.sphere:disableTextures() end
end \; function M.texturemap(l) M.sphere:mapTexCoords(l[1] \, l[2]
\, l[3] \, l[4]) end \; function M.imageID(sym) \; if sym == nil then
M.imageSource = nil M.lastID = nil return("imageID") \; else if sym
~= lastID then \; M.imageSource = require(sym) \; M.lastID = sym \;
return ofTable("imageID" \, sym) \; end \; end \; end \; \; function
M.bang() \; ofSetLineWidth(strokeweight) \; if M.imageSource ~= nil
then M.imageSource.image:getTexture():bind() end \; if drawmode ==
"fill" then M.sphere:drawFaces() end \; if drawmode == "point" then
M.sphere:drawVertices() end \; if drawmode == "line" then M.sphere:drawWireframe()
end \; if drawmode == "normal" then M.sphere:drawNormals(normalsize)
end \; if debug > 0 then M.sphere:drawAxes(debug*100) end \; if M.imageSource
~= nil then M.imageSource.image:getTexture():unbind() end \; return
anything \; end \;;
#X f 116;
#X connect 0 0 9 0;
#X connect 2 0 4 0;
#X connect 3 0 5 0;
#X connect 4 0 9 0;
#X connect 5 0 9 0;
#X connect 8 0 1 0;
#X connect 9 0 8 0;
